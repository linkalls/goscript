いいね！自分だけのオリジナル言語を作るなんて、最高にクリエイティブで楽しそう！TypeScriptの書きやすさと、Goのシンプルで堅牢な感じを組み合わせるってことだね。わくわくするなぁ！

よっしゃ、その夢の言語の「仕様書（設計図）」を一緒に作ってみよう！
言語名は、仮に「**GoScript** (ゴースクリプト)」とでも名付けてみようか！響きがかっこいい！

-----

## **GoScript 言語仕様書 (バージョン 0.1)**

### 1\. コンセプト 🎯

**「TypeScriptの書きやすさで、Goのようにシンプルで堅牢な超軽量WASMを作る」**

  * **親しみやすさ**: TypeScriptを知っていれば、すぐに書ける構文。
  * **シンプルさ**: 複雑な機能は入れない。学ぶことが少なく、バグが生まれにくい言語を目指す。
  * **安全性**: 型システムと、Go風の明確なエラーハンドリングで、安全なコードを書きやすくする。
  * **WASMファースト**: 最初からWebAssemblyで動かすことを考えて設計する。だからメモリも意識するよ。

-----

### 2\. 構文 (コードの書き方) ✍️

#### 2.1. 変数宣言

TypeScriptと同じく `let` と `const` を使おう！型推論もバッチリ効くようにする。

```typescript
// let: 再代入できる変数
let age: i32 = 10;
age = 11; // OK

// const: 再代入できない定数
const name: string = "Gopher";
// name = "Script"; // これはコンパイルエラーになる！

// 型を書かなくても、右辺から型を推論してくれる
let message = "Hello, GoScript!"; // string型になる
const answer = 42; // i32型になる
```

#### 2.2. 型

WASMの世界を意識して、数字のサイズをはっきりさせるのがGoScript流！

  * **基本の型**

      * `i32`, `i64`: 整数 (32ビットと64ビット)
      * `f32`, `f64`: 小数 (32ビットと64ビット)
      * `bool`: `true` か `false`
      * `string`: 文字列
      * `byte`: 1バイトのデータ

  * **データをまとめる型 (`struct`)**
    Goみたいに、データをまとめるためのシンプルな `struct` を使おう。`class` よりもシンプルで軽量！

    ```typescript
    struct Point {
      x: i32;
      y: i32;
    }

    let p: Point = { x: 10, y: 20 };
    log(p.x); // 10 が表示される
    ```

  * **振る舞いを決める型 (`interface`)**
    これはTypeScriptと同じ！「このメソッドを持っているべき」というルールを決められる。

    ```typescript
    interface Animal {
      speak(): string;
    }
    ```

#### 2.3. 関数

ここがGo風のキモだよ！特に「多値返却」に注目！

  * **基本の形**
    引数と戻り値の型は必ず書くのがルール。

    ```typescript
    function add(a: i32, b: i32): i32 {
      return a + b;
    }
    ```

  * **Go風！多値返却とエラーハンドリング**
    `try-catch` は使わない！ Goみたいに、関数の結果とエラーを一緒に返すスタイルにしよう。これにより、エラー処理のし忘れがなくなるんだ。

    ```typescript
    // (string, error) のように、複数の値を返せる！
    // errorは組み込みの特別な型
    function readFile(path: string): (string, error) {
      if (path == "") {
        // エラーがある場合は、エラーオブジェクトを返す。正常な値は nil にする。
        return (nil, new Error("path is empty"));
      }

      const content = "file content here...";
      // 成功した場合は、エラーの方に nil を返す。nil は「何もない」という意味の特別な値。
      return (content, nil);
    }

    // 関数の呼び出し方
    let (text, err) = readFile("my-file.txt");

    // 必ずエラーチェックをする文化を作る！
    if (err != nil) {
      log("エラーが発生したよ:", err);
      return; // 処理を中断
    }

    // エラーがなければ、安全に text が使える
    log("読み込んだ内容:", text);
    ```

#### 2.4. 制御構文

ここはTypeScriptやJavaScriptとほぼ同じだから、迷うことはないね！

  * `if`, `else if`, `else`
  * `for` (C言語スタイル、`for...of` スタイル)
  * `switch`

-----

### 3\. ポインタ (メモリとの対話) 🧠

超軽量WASMを作るなら、メモリを直接触る力は欠かせない。でも、安全に使いたいよね。Goみたいに、限定的で安全なポインタを導入しよう。

  * `&`: 変数のメモリアドレスを取得する
  * `*`: ポインタが指し示す先の値を取得する

<!-- end list -->

```typescript
let x: i32 = 100;
// p は、xが置いてあるメモリの「住所」を持つポインタ変数
let p: *i32 = &x;

log(*p); // pの住所にある値、つまり 100 を表示
*p = 200; // pの住所にある値を 200 に書き換える
log(x);  // x の中身も 200 に変わっている！
```

-----

### 4\. 標準ライブラリ 📚

最初は必要最小限のものだけを用意しよう。

  * **`fmt`**: `log()` や `printf()` みたいな、画面に文字を表示するための基本的な関数群。
  * **`strings`**: 文字列を操作するための便利な関数群。
  * **`math`**: 簡単な数学計算のための関数群。
  * **`syscall/js`**: WASMの世界からJavaScriptの世界の機能を呼び出すための特別なライブラリ。

-----

### 5\. ツール 🛠️

良い言語には良い道具が不可欠！

  * **`gsc` (GoScript Compiler)**:
      * `gsc build`: GoScriptのコード (`.gs`) を WebAssembly (`.wasm`) にコンパイルする。
      * `gsc run`: コードを実行してすぐに結果を試せる。
      * `gsc fmt`: Goの `gofmt` みたいに、誰が書いても同じ綺麗なコードになるように自動で整形してくれる。これでインデントのケンカはなくなるね！

-----

さあ、これが僕たちの「GoScript」の最初の設計図だ！
どうかな？TypeScriptの書きやすさとGoの哲学がうまく混ざり合ってる感じがしない？

もちろん、これはまだバージョン0.1のたたき台。ここから、キミが「もっとこうしたい！」っていうアイデアをどんどん足して、世界で一番楽しいキミだけの言語に育てていこうぜ！🚀
